<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edge Detection Particle Animation</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>
    <div id="controls">
        <div class="input-group">
            <input type="file" id="imageInput" accept="image/*">
            <button id="restartBtn">Restart Animation</button>
            <div id="info">Upload an image to begin</div>
        </div>
    </div>
    <canvas id="canvas"></canvas>

    <!-- Render Vertex Shader -->
    <script type="x-shader/x-vertex" id="particleVertexShader">#version 300 es
in vec2 position;
in vec2 velocity;
in vec2 target;

uniform float particleSize;

out vec2 vPosition;
out vec2 vVelocity;
out vec2 vTarget;

void main() {
    vPosition = position;
    vVelocity = velocity;
    vTarget = target;
    gl_Position = vec4(position * 2.0 - 1.0, 0, 1);
    gl_PointSize = 2.0 * particleSize;
}</script>

    <!-- Render Fragment Shader -->
    <script type="x-shader/x-fragment" id="particleFragmentShader">#version 300 es
precision highp float;

in vec2 vPosition;
uniform vec3 uParticleColor;
uniform float uParticleOpacity;

out vec4 fragColor;

void main() {
    float dist = length(gl_PointCoord - vec2(0.5));
    if (dist > 0.5) discard;
    fragColor = vec4(uParticleColor, uParticleOpacity);
}</script>

    <!-- Update Vertex Shader -->
    <script type="x-shader/x-vertex" id="updateVertexShader">#version 300 es
      in vec2 position;
      in vec2 velocity;
      in vec2 target;
      
      out vec2 vPosition;
      out vec2 vVelocity;
      out vec2 vTarget;
      
      uniform sampler2D edgeTexture;
      uniform float deltaTime;
      uniform vec2 resolution;
      uniform float particleSpeed;
      uniform float searchRadius;
      uniform float attractionStrength;
      uniform float time;  // New uniform for time-based flow
      
      float rand(vec2 co) {
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
      }
      
      // Flow field function using simplex-like noise
      vec2 flowField(vec2 position, float time) {
          float scale = 4.0;  // Scale of the flow field
          vec2 scaledPos = position * scale;
          
          // Create two offset sine waves for x and y components
          float angle = sin(scaledPos.x + time * 0.2) * cos(scaledPos.y + time * 0.15) * 3.14159;
          
          // Create rotational flow vector
          return vec2(cos(angle), sin(angle));
      }
      
      void main() {
          vec2 pos = position;
          vec2 vel = velocity;
          vec2 tgt = target;
          
          // Check if we're on an edge
          vec4 edge = texture(edgeTexture, pos);
          
          if (edge.r > 0.5) {
              // Particle is on an edge - keep it mostly still with slight movement
              vel *= 0.95;  // Damping
              vel += (vec2(rand(pos.xy), rand(pos.yx)) - 0.5) * 0.0001;  // Tiny random movement
              tgt = vec2(-1.0);
          } else {
              // Not on edge - check for nearby edges
              float closestDist = searchRadius;
              vec2 closestEdge = pos;
              bool foundEdge = false;
              
              // Search for nearby edges
              for (float y = -5.0; y <= 5.0; y += 1.0) {
                  for (float x = -5.0; x <= 5.0; x += 1.0) {
                      vec2 offset = vec2(x, y) / resolution;
                      vec2 samplePos = pos + offset;
                      
                      if (samplePos.x < 0.0 || samplePos.x > 1.0 || 
                          samplePos.y < 0.0 || samplePos.y > 1.0) continue;
                      
                      vec4 sampleEdge = texture(edgeTexture, samplePos);
                      if (sampleEdge.r > 0.5) {
                          float dist = length(offset);
                          if (dist < closestDist) {
                              closestDist = dist;
                              closestEdge = samplePos;
                              foundEdge = true;
                          }
                      }
                  }
              }
              
              if (foundEdge) {
                  // Move towards the edge
                  vec2 toEdge = normalize(closestEdge - pos);
                  vel = toEdge * particleSpeed * attractionStrength;
                  tgt = closestEdge;
              } else {
                  // Follow the flow field
                  vec2 flow = flowField(pos, time);
                  vel = mix(vel, flow * particleSpeed, 0.1);  // Smooth transition
                  tgt = vec2(-1.0);
              }
          }
          
          // Update position
          pos += vel * deltaTime;
          
          // Handle boundary conditions - allow particles to flow off the canvas
          if (pos.x < -0.1 || pos.x > 1.1 || pos.y < -0.1 || pos.y > 1.1) {
              // Reset particle to opposite side with some randomness
              if (abs(pos.x - 0.5) > abs(pos.y - 0.5)) {
                  pos.x = pos.x < 0.0 ? 1.0 : 0.0;
                  pos.y = rand(vec2(pos.y, time));
              } else {
                  pos.x = rand(vec2(pos.x, time));
                  pos.y = pos.y < 0.0 ? 1.0 : 0.0;
              }
              vel = vec2(0.0);
          }
          
          vPosition = pos;
          vVelocity = vel;
          vTarget = tgt;
      }</script>

    <!-- Edge Detection Vertex Shader -->
    <script type="x-shader/x-vertex" id="edgeVertexShader">#version 300 es
in vec2 aPosition;
out vec2 vTexCoord;

void main() {
    // Flip the y coordinate here for texture coordinates
    vTexCoord = vec2(aPosition.x * 0.5 + 0.5, 1.0 - (aPosition.y * 0.5 + 0.5));
    gl_Position = vec4(aPosition, 0.0, 1.0);
}</script>

    <!-- Edge Detection Fragment Shader -->
    <script type="x-shader/x-fragment" id="edgeFragmentShader">#version 300 es
precision highp float;

in vec2 vTexCoord;
uniform sampler2D uImage;
uniform vec2 uResolution;
uniform float threshold;
out vec4 fragColor;

void main() {
    vec2 texel = 1.0 / uResolution;
    // Use vTexCoord directly since it's already flipped in the vertex shader
    vec2 tc = vTexCoord;
    
    vec3 tl = texture(uImage, tc + texel * vec2(-1, -1)).rgb;
    vec3 t  = texture(uImage, tc + texel * vec2( 0, -1)).rgb;
    vec3 tr = texture(uImage, tc + texel * vec2( 1, -1)).rgb;
    vec3 l  = texture(uImage, tc + texel * vec2(-1,  0)).rgb;
    vec3 c  = texture(uImage, tc).rgb;
    vec3 r  = texture(uImage, tc + texel * vec2( 1,  0)).rgb;
    vec3 bl = texture(uImage, tc + texel * vec2(-1,  1)).rgb;
    vec3 b  = texture(uImage, tc + texel * vec2( 0,  1)).rgb;
    vec3 br = texture(uImage, tc + texel * vec2( 1,  1)).rgb;

    vec3 gx = -tl - 2.0 * l - bl + tr + 2.0 * r + br;
    vec3 gy = -tl - 2.0 * t - tr + bl + 2.0 * b + br;
    
    float edge = length(gx) + length(gy);
    edge = edge > threshold ? 1.0 : 0.0;
    
    fragColor = vec4(edge, edge, edge, 1.0);
}</script>

    <!-- Application Scripts -->
    <script src="webgl-utils.js"></script>
    <script src="particles.js"></script>
    <script src="main.js"></script>
</body>
</html>